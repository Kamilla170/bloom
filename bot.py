import asyncio
import os
import logging
from datetime import datetime, timedelta
import json
import base64
from io import BytesIO

from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiohttp import web
from openai import AsyncOpenAI
from PIL import Image

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏
BOT_TOKEN = os.getenv("BOT_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
WEBHOOK_URL = os.getenv("WEBHOOK_URL")
PORT = int(os.getenv("PORT", 8000))

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher(storage=MemoryStorage())
openai_client = AsyncOpenAI(api_key=OPENAI_API_KEY)

# –ü—Ä–æ—Å—Ç–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –≤ –ø–∞–º—è—Ç–∏ (–≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö)
users_data = {}

# –°–æ—Å—Ç–æ—è–Ω–∏—è
class PlantStates(StatesGroup):
    waiting_question = State()

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã
def main_menu():
    keyboard = [
        [InlineKeyboardButton(text="üì∏ –ê–Ω–∞–ª–∏–∑ —Ä–∞—Å—Ç–µ–Ω–∏—è", callback_data="analyze")],
        [InlineKeyboardButton(text="‚ùì –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å", callback_data="question")],
        [InlineKeyboardButton(text="üå± –ú–æ–∏ —Ä–∞—Å—Ç–µ–Ω–∏—è", callback_data="my_plants")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=keyboard)

def after_analysis():
    keyboard = [
        [InlineKeyboardButton(text="üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å", callback_data="save_plant")],
        [InlineKeyboardButton(text="‚ùì –í–æ–ø—Ä–æ—Å –æ —Ä–∞—Å—Ç–µ–Ω–∏–∏", callback_data="ask_about")],
        [InlineKeyboardButton(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="menu")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=keyboard)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
async def optimize_image(image_data: bytes) -> bytes:
    """–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
    try:
        image = Image.open(BytesIO(image_data))
        if image.mode != 'RGB':
            image = image.convert('RGB')
        
        # –£–º–µ–Ω—å—à–∞–µ–º –µ—Å–ª–∏ –±–æ–ª—å—à–µ 1024px
        if max(image.size) > 1024:
            image.thumbnail((1024, 1024), Image.Resampling.LANCZOS)
        
        output = BytesIO()
        image.save(output, format='JPEG', quality=85, optimize=True)
        return output.getvalue()
    except:
        return image_data

# –ê–Ω–∞–ª–∏–∑ —Ä–∞—Å—Ç–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é OpenAI
async def analyze_plant_image(image_data: bytes, user_question: str = None) -> dict:
    """–ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ä–∞—Å—Ç–µ–Ω–∏—è"""
    try:
        # –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        optimized_image = await optimize_image(image_data)
        base64_image = base64.b64encode(optimized_image).decode('utf-8')
        
        # –ë–∞–∑–æ–≤—ã–π –ø—Ä–æ–º–ø—Ç
        prompt = """
        –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç–æ —Ä–∞—Å—Ç–µ–Ω–∏–µ –∏ –¥–∞–π –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é:
        
        1. –ù–∞–∑–≤–∞–Ω–∏–µ —Ä–∞—Å—Ç–µ–Ω–∏—è (–æ–±—ã—á–Ω–æ–µ –∏ –Ω–∞—É—á–Ω–æ–µ)
        2. –°–µ–º–µ–π—Å—Ç–≤–æ
        3. –°–æ—Å—Ç–æ—è–Ω–∏–µ —Ä–∞—Å—Ç–µ–Ω–∏—è (–∑–¥–æ—Ä–æ–≤—å–µ)
        4. –ü—Ä–æ–±–ª–µ–º—ã –µ—Å–ª–∏ –µ—Å—Ç—å
        5. –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —É—Ö–æ–¥—É:
           - –ü–æ–ª–∏–≤ (–∫–∞–∫ —á–∞—Å—Ç–æ)
           - –û—Å–≤–µ—â–µ–Ω–∏–µ
           - –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞
           - –í–ª–∞–∂–Ω–æ—Å—Ç—å
           - –ü–æ–¥–∫–æ—Ä–º–∫–∞
        6. –°–æ–≤–µ—Ç—ã –ø–æ —Å–µ–∑–æ–Ω–Ω–æ–º—É —É—Ö–æ–¥—É
        
        –û—Ç–≤–µ—á–∞–π –ø–æ–¥—Ä–æ–±–Ω–æ –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ.
        """
        
        if user_question:
            prompt += f"\n\n–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –æ—Ç–≤–µ—Ç—å –Ω–∞ –≤–æ–ø—Ä–æ—Å: {user_question}"
        
        response = await openai_client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": prompt},
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{base64_image}",
                                "detail": "high"
                            }
                        }
                    ]
                }
            ],
            max_tokens=1500,
            temperature=0.3
        )
        
        return {
            "success": True,
            "analysis": response.choices[0].message.content
        }
        
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
@dp.message(Command("start"))
async def start_command(message: types.Message):
    """–ö–æ–º–∞–Ω–¥–∞ /start"""
    user_id = message.from_user.id
    if user_id not in users_data:
        users_data[user_id] = {
            "plants": [],
            "reminders": []
        }
    
    await message.answer(
        f"üå± –ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}!\n\n"
        "–Ø –ø–æ–º–æ–≥—É —Ç–µ–±–µ —É—Ö–∞–∂–∏–≤–∞—Ç—å –∑–∞ —Ä–∞—Å—Ç–µ–Ω–∏—è–º–∏:\n"
        "üì∏ –ü—Ä–∏—à–ª–∏ —Ñ–æ—Ç–æ —Ä–∞—Å—Ç–µ–Ω–∏—è –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞\n"
        "‚ùì –ó–∞–¥–∞–π –≤–æ–ø—Ä–æ—Å –æ —Ä–∞—Å—Ç–µ–Ω–∏—è—Ö\n"
        "üåø –ü–æ–ª—É—á–∞–π –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ –ø–æ–ª–∏–≤–µ",
        reply_markup=main_menu()
    )

@dp.message(Command("help"))
async def help_command(message: types.Message):
    """–ö–æ–º–∞–Ω–¥–∞ /help"""
    help_text = """
üå± <b>–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º:</b>

üì∏ <b>–ê–Ω–∞–ª–∏–∑ —Ä–∞—Å—Ç–µ–Ω–∏—è:</b>
‚Ä¢ –ü—Ä–∏—à–ª–∏ —Ñ–æ—Ç–æ —Ä–∞—Å—Ç–µ–Ω–∏—è
‚Ä¢ –ü–æ–ª—É—á–∏ –ø–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
‚Ä¢ –°–æ—Ö—Ä–∞–Ω–∏ —Ä–∞—Å—Ç–µ–Ω–∏–µ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—é

‚ùì <b>–í–æ–ø—Ä–æ—Å—ã –æ —Ä–∞—Å—Ç–µ–Ω–∏—è—Ö:</b>
‚Ä¢ –ù–∞–∂–º–∏ "–ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å"
‚Ä¢ –û–ø–∏—à–∏ –ø—Ä–æ–±–ª–µ–º—É –∏–ª–∏ –∑–∞–¥–∞–π –ª—é–±–æ–π –≤–æ–ø—Ä–æ—Å
‚Ä¢ –ü–æ–ª—É—á–∏ —ç–∫—Å–ø–µ—Ä—Ç–Ω—ã–π —Å–æ–≤–µ—Ç

üåø <b>–ú–æ–∏ —Ä–∞—Å—Ç–µ–Ω–∏—è:</b>
‚Ä¢ –ü—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞–π —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ —Ä–∞—Å—Ç–µ–Ω–∏—è
‚Ä¢ –û—Ç–º–µ—á–∞–π –ø–æ–ª–∏–≤ –∏ —É—Ö–æ–¥
‚Ä¢ –ü–æ–ª—É—á–∞–π –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è

<b>–ö–æ–º–∞–Ω–¥—ã:</b>
/start - –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
/help - —ç—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞
    """
    await message.answer(help_text, parse_mode="HTML", reply_markup=main_menu())

# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π
@dp.message(F.photo)
async def handle_photo(message: types.Message):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π —Ä–∞—Å—Ç–µ–Ω–∏–π"""
    try:
        processing_msg = await message.reply("üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –≤–∞—à–µ —Ä–∞—Å—Ç–µ–Ω–∏–µ...")
        
        # –ü–æ–ª—É—á–∞–µ–º —Ñ–æ—Ç–æ
        photo = message.photo[-1]
        file = await bot.get_file(photo.file_id)
        file_data = await bot.download_file(file.file_path)
        
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º
        user_question = message.caption if message.caption else None
        result = await analyze_plant_image(file_data.read(), user_question)
        
        await processing_msg.delete()
        
        if result["success"]:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∞–Ω–∞–ª–∏–∑ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            user_id = message.from_user.id
            if user_id not in users_data:
                users_data[user_id] = {"plants": [], "reminders": []}
            
            users_data[user_id]["last_analysis"] = {
                "analysis": result["analysis"],
                "photo_file_id": photo.file_id,
                "date": datetime.now()
            }
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            analysis = result["analysis"]
            if len(analysis) > 4000:
                analysis = analysis[:4000] + "...\n\nüí¨ –ü–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω"
            
            await message.reply(
                f"üå± <b>–ê–Ω–∞–ª–∏–∑ —Ä–∞—Å—Ç–µ–Ω–∏—è:</b>\n\n{analysis}",
                parse_mode="HTML",
                reply_markup=after_analysis()
            )
        else:
            await message.reply(f"‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞: {result['error']}")
            
    except Exception as e:
        await message.reply("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")

# Callback –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
@dp.callback_query(F.data == "analyze")
async def analyze_callback(callback: types.CallbackQuery):
    await callback.message.answer("üì∏ –ü—Ä–∏—à–ª–∏—Ç–µ —Ñ–æ—Ç–æ —Ä–∞—Å—Ç–µ–Ω–∏—è –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞")
    await callback.answer()

@dp.callback_query(F.data == "question")
async def question_callback(callback: types.CallbackQuery, state: FSMContext):
    await callback.message.answer("‚ùì –ó–∞–¥–∞–π—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å –æ —Ä–∞—Å—Ç–µ–Ω–∏—è—Ö:")
    await state.set_state(PlantStates.waiting_question)
    await callback.answer()

@dp.message(StateFilter(PlantStates.waiting_question))
async def handle_question(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤"""
    try:
        processing_msg = await message.reply("ü§î –î—É–º–∞—é –Ω–∞–¥ –æ—Ç–≤–µ—Ç–æ–º...")
        
        # –û–±—Ä–∞—â–∞–µ–º—Å—è –∫ OpenAI
        response = await openai_client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {
                    "role": "system",
                    "content": "–¢—ã —ç–∫—Å–ø–µ—Ä—Ç –ø–æ —Ä–∞—Å—Ç–µ–Ω–∏—è–º –∏ —Ü–≤–µ—Ç–∞–º. –û—Ç–≤–µ—á–∞–π –ø–æ–¥—Ä–æ–±–Ω–æ –∏ –ø—Ä–∞–∫—Ç–∏—á–Ω–æ –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ."
                },
                {
                    "role": "user",
                    "content": message.text
                }
            ],
            max_tokens=1000,
            temperature=0.4
        )
        
        await processing_msg.delete()
        
        answer = response.choices[0].message.content
        await message.reply(f"üåø <b>–û—Ç–≤–µ—Ç —ç–∫—Å–ø–µ—Ä—Ç–∞:</b>\n\n{answer}", parse_mode="HTML", reply_markup=main_menu())
        await state.clear()
        
    except Exception as e:
        await message.reply("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        await state.clear()

@dp.callback_query(F.data == "save_plant")
async def save_plant_callback(callback: types.CallbackQuery):
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–∞—Å—Ç–µ–Ω–∏—è"""
    user_id = callback.from_user.id
    
    if user_id in users_data and "last_analysis" in users_data[user_id]:
        analysis_data = users_data[user_id]["last_analysis"]
        
        # –ü—Ä–æ—Å—Ç–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç—å
        plant = {
            "id": len(users_data[user_id]["plants"]) + 1,
            "analysis": analysis_data["analysis"],
            "photo_file_id": analysis_data["photo_file_id"],
            "saved_date": datetime.now(),
            "last_watered": None
        }
        
        users_data[user_id]["plants"].append(plant)
        
        await callback.message.answer(
            "‚úÖ –†–∞—Å—Ç–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ!\n"
            "–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –æ—Ç–º–µ—á–∞—Ç—å –ø–æ–ª–∏–≤ –∏ –ø–æ–ª—É—á–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è.",
            reply_markup=main_menu()
        )
    else:
        await callback.message.answer("‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è. –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —Ä–∞—Å—Ç–µ–Ω–∏–µ.")
    
    await callback.answer()

@dp.callback_query(F.data == "my_plants")
async def my_plants_callback(callback: types.CallbackQuery):
    """–ü—Ä–æ—Å–º–æ—Ç—Ä —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö —Ä–∞—Å—Ç–µ–Ω–∏–π"""
    user_id = callback.from_user.id
    
    if user_id not in users_data or not users_data[user_id]["plants"]:
        await callback.message.answer(
            "üå± –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö —Ä–∞—Å—Ç–µ–Ω–∏–π.\n"
            "–ü—Ä–∏—à–ª–∏—Ç–µ —Ñ–æ—Ç–æ —Ä–∞—Å—Ç–µ–Ω–∏—è –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞!",
            reply_markup=main_menu()
        )
        await callback.answer()
        return
    
    plants = users_data[user_id]["plants"]
    text = f"üåø <b>–í–∞—à–∏ —Ä–∞—Å—Ç–µ–Ω–∏—è ({len(plants)}):</b>\n\n"
    
    for i, plant in enumerate(plants[-5:], 1):  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5
        saved_date = plant["saved_date"].strftime("%d.%m.%Y")
        watered = plant["last_watered"].strftime("%d.%m") if plant["last_watered"] else "–Ω–∏–∫–æ–≥–¥–∞"
        
        text += f"{i}. –†–∞—Å—Ç–µ–Ω–∏–µ #{plant['id']}\n"
        text += f"   üìÖ –î–æ–±–∞–≤–ª–µ–Ω–æ: {saved_date}\n"
        text += f"   üíß –ü–æ–ª–∏–≤: {watered}\n\n"
    
    # –ö–Ω–æ–ø–∫–∏ –¥–ª—è –¥–µ–π—Å—Ç–≤–∏–π —Å —Ä–∞—Å—Ç–µ–Ω–∏—è–º–∏
    keyboard = [
        [InlineKeyboardButton(text="üíß –û—Ç–º–µ—Ç–∏—Ç—å –ø–æ–ª–∏–≤", callback_data="water_plants")],
        [InlineKeyboardButton(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="menu")],
    ]
    
    await callback.message.answer(text, parse_mode="HTML", reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard))
    await callback.answer()

@dp.callback_query(F.data == "water_plants")
async def water_plants_callback(callback: types.CallbackQuery):
    """–û—Ç–º–µ—Ç–∫–∞ –ø–æ–ª–∏–≤–∞"""
    user_id = callback.from_user.id
    
    if user_id in users_data and users_data[user_id]["plants"]:
        # –û—Ç–º–µ—á–∞–µ–º –ø–æ–ª–∏–≤ –¥–ª—è –≤—Å–µ—Ö —Ä–∞—Å—Ç–µ–Ω–∏–π
        for plant in users_data[user_id]["plants"]:
            plant["last_watered"] = datetime.now()
        
        await callback.message.answer(
            "‚úÖ –ü–æ–ª–∏–≤ –æ—Ç–º–µ—á–µ–Ω –¥–ª—è –≤—Å–µ—Ö —Ä–∞—Å—Ç–µ–Ω–∏–π!\n"
            "–ù–µ –∑–∞–±—É–¥—å—Ç–µ –ø–æ–ª–∏—Ç—å –∏—Ö —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π.",
            reply_markup=main_menu()
        )
    else:
        await callback.message.answer("‚ùå –ù–µ—Ç —Ä–∞—Å—Ç–µ–Ω–∏–π –¥–ª—è –ø–æ–ª–∏–≤–∞.")
    
    await callback.answer()

@dp.callback_query(F.data == "menu")
async def menu_callback(callback: types.CallbackQuery):
    await callback.message.answer("üå± –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=main_menu())
    await callback.answer()

@dp.callback_query(F.data == "ask_about")
async def ask_about_callback(callback: types.CallbackQuery, state: FSMContext):
    """–í–æ–ø—Ä–æ—Å –æ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–º —Ä–∞—Å—Ç–µ–Ω–∏–∏"""
    user_id = callback.from_user.id
    
    if user_id in users_data and "last_analysis" in users_data[user_id]:
        await callback.message.answer(
            "‚ùì –ó–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å –æ–± —ç—Ç–æ–º —Ä–∞—Å—Ç–µ–Ω–∏–∏:\n"
            "–ù–∞–ø—Ä–∏–º–µ—Ä: '–ü–æ—á–µ–º—É –∂–µ–ª—Ç–µ—é—Ç –ª–∏—Å—Ç—å—è?' –∏–ª–∏ '–ö–∞–∫ —á–∞—Å—Ç–æ –ø–æ–ª–∏–≤–∞—Ç—å?'"
        )
        await state.set_state(PlantStates.waiting_question)
    else:
        await callback.message.answer("‚ùå –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —Ä–∞—Å—Ç–µ–Ω–∏–µ.")
    
    await callback.answer()

# Webhook setup –¥–ª—è Railway
async def on_startup():
    if WEBHOOK_URL:
        await bot.set_webhook(f"{WEBHOOK_URL}/webhook")
        print(f"Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {WEBHOOK_URL}/webhook")
    else:
        await bot.delete_webhook(drop_pending_updates=True)
        print("Webhook —É–¥–∞–ª–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è polling")

async def on_shutdown():
    await bot.session.close()

# Webhook handler
async def webhook_handler(request):
    url = str(request.url)
    index = url.rfind('/')
    token = url[index + 1:]
    
    if token == BOT_TOKEN.split(':')[1]:  # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞
        update = types.Update.model_validate(await request.json(), strict=False)
        await dp.feed_update(bot, update)
        return web.Response()
    else:
        return web.Response(status=403)

# Health check –¥–ª—è Railway
async def health_check(request):
    return web.json_response({"status": "healthy"})

# –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
async def main():
    logging.basicConfig(level=logging.INFO)
    
    await on_startup()
    
    if WEBHOOK_URL:
        # Webhook —Ä–µ–∂–∏–º –¥–ª—è Railway
        app = web.Application()
        app.router.add_post('/webhook', webhook_handler)
        app.router.add_get('/health', health_check)
        
        runner = web.AppRunner(app)
        await runner.setup()
        site = web.TCPSite(runner, '0.0.0.0', PORT)
        await site.start()
        
        print(f"üöÄ Webhook —Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É {PORT}")
        
        # –î–µ—Ä–∂–∏–º —Å–µ—Ä–≤–µ—Ä —Ä–∞–±–æ—Ç–∞—é—â–∏–º
        try:
            await asyncio.Future()
        except KeyboardInterrupt:
            pass
        finally:
            await runner.cleanup()
            await on_shutdown()
    else:
        # Polling —Ä–µ–∂–∏–º –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
        print("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –≤ —Ä–µ–∂–∏–º–µ polling")
        try:
            await dp.start_polling(bot)
        finally:
            await on_shutdown()

if __name__ == "__main__":
    asyncio.run(main())
